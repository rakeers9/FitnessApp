// src/services/aiService.ts

import { ConversationState, ChatMessage, UserPlanInfo, WorkoutPlan } from '../context/AITrainerContextSafe';
import { supabase } from './supabase';

// OpenAI API configuration
const OPENAI_API_URL = 'https://api.openai.com/v1/chat/completions';
const OPENAI_MODEL = 'gpt-4o-mini'; // Using GPT-4o mini for production

// Rate limiting and retry configuration
const MAX_RETRIES = 3;
const RETRY_DELAY = 1000;

interface AIServiceResponse {
  content: string;
  newState?: ConversationState;
  quickReplies?: QuickReply[];
  planData?: WorkoutPlan;
  userInfoUpdates?: Partial<UserPlanInfo>;
  metadata?: any;
}

interface QuickReply {
  id: string;
  text: string;
  action: string;
  data?: any;
}

// System prompts for different conversation states
const SYSTEM_PROMPTS = {
  IDLE: `You are an AI personal trainer in a fitness app. You're knowledgeable, encouraging, and professional.

Key behaviors:
- Give helpful fitness advice, workout tips, and answer questions naturally
- When users ask about creating workout plans (like "make me a plan", "I need a routine", "create a program"), detect this intent and offer to build a personalized plan
- For plan requests, be encouraging and explain what you'll create
- Keep responses conversational and supportive
- Don't be overly formal - sound like a knowledgeable fitness coach

If you detect a plan creation request, respond with enthusiasm and explain you can build a personalized plan for their goals.`,

  PLAN_CONFIRM: `You are confirming whether to create a workout plan. Be clear about what you'll do:

1. Explain you'll collect their fitness info
2. Generate a personalized workout plan  
3. Add it to their app calendar
4. Be encouraging about the process

Keep the tone supportive and professional.`,

  PLAN_INFO_GATHER: `You are collecting workout plan information. Be efficient but friendly.

Collect this info step by step:
- Fitness goal (fat loss, muscle gain, strength, general fitness)
- Experience level (beginner, intermediate, advanced) 
- Schedule (days per week 2-6, which days)
- Session length (30, 45, 60, or 90 minutes)
- Equipment available
- Injuries or limitations
- Training preferences

Ask 1-2 questions at a time. Be encouraging and explain why you need each piece of info.`,

  PLAN_BUILDING: `You are generating a workout plan. Stay encouraging while working.`,

  PLAN_PERSISTING: `You are saving the workout plan. Keep the user informed of progress.`,

  PLAN_EXPLAINED: `You have successfully created and saved a workout plan. Now explain how to use it:

1. Overview of their plan structure
2. How to progress (add weight, reps, etc.)
3. Warm-up recommendations
4. How to modify if needed
5. General tips for success

Be encouraging and emphasize they can always ask questions.`
};

// Available muscle groups (from ExerciseLibraryScreen)
const VALID_MUSCLE_GROUPS = [
  'Chest', 'Back', 'Shoulders', 'Biceps', 'Triceps', 'Forearms',
  'Abs', 'Quads', 'Hamstrings', 'Calves', 'Glutes'
];

// Intent detection patterns
const PLAN_INTENT_PATTERNS = [
  /create.*plan/i,
  /make.*plan/i,
  /build.*routine/i,
  /workout.*plan/i,
  /training.*program/i,
  /need.*routine/i,
  /design.*workout/i,
  /custom.*plan/i,
  /personalized.*routine/i,
  /program.*for.*me/i,
  /\b(ppl|push.*pull.*legs)\b/i,
  /upper.*lower/i,
  /full.*body/i,
  /split.*routine/i,
];

const STOP_PLAN_INTENT_PATTERNS = [
  /stop.*plan/i,
  /cancel.*plan/i,
  /stop.*building/i,
  /cancel.*building/i,
  /quit.*plan/i,
  /abort.*plan/i,
  /stop.*this/i,
  /cancel.*this/i,
  /never.*mind/i,
  /forget.*it/i,
  /don't.*want.*plan/i,
  /stop.*creating/i,
  /cancel.*creation/i,
];

class AIService {
  private apiKey: string;

  constructor() {
    this.apiKey = process.env.EXPO_PUBLIC_OPENAI_API_KEY || '';
    if (!this.apiKey) {
      console.warn('OpenAI API key not found. AI features will be disabled.');
    }
  }

  // Main method to process user messages
  async processMessage(
    message: string,
    currentState: ConversationState,
    conversationHistory: ChatMessage[],
    userPlanInfo: UserPlanInfo
  ): Promise<AIServiceResponse> {
    try {
      // Detect intent if in IDLE state
      if (currentState === 'IDLE' && this.detectPlanIntent(message)) {
        return this.handlePlanIntentDetected();
      }

      // Detect stop intent during plan creation states
      if (['PLAN_CONFIRM', 'PLAN_INFO_GATHER', 'PLAN_BUILDING'].includes(currentState) && this.detectStopPlanIntent(message)) {
        return this.handleStopPlanIntentDetected();
      }

      // Handle different conversation states
      switch (currentState) {
        case 'IDLE':
          return await this.handleIdleChat(message, conversationHistory);
          
        case 'PLAN_CONFIRM':
          return this.handlePlanConfirmation(message);
          
        case 'PLAN_INFO_GATHER':
          return await this.handleInfoGathering(message, userPlanInfo);
          
        case 'PLAN_BUILDING':
          return await this.handlePlanBuilding(userPlanInfo);
          
        case 'PLAN_EXPLAINED':
          return await this.handlePostPlanQuestions(message, userPlanInfo);
          
        case 'STOP_PLAN_CONFIRM':
          return this.handleStopPlanConfirmation(message);
          
        default:
          return await this.handleIdleChat(message, conversationHistory);
      }
    } catch (error) {
      console.error('AI Service Error:', error);
      return this.getErrorResponse();
    }
  }

  // Detect if user wants to create a workout plan
  private detectPlanIntent(message: string): boolean {
    return PLAN_INTENT_PATTERNS.some(pattern => pattern.test(message));
  }

  // Detect if user wants to stop creating a workout plan
  private detectStopPlanIntent(message: string): boolean {
    return STOP_PLAN_INTENT_PATTERNS.some(pattern => pattern.test(message));
  }

  // Handle plan intent detection
  private handlePlanIntentDetected(): AIServiceResponse {
    return {
      content: "I'd love to help you create a personalized workout plan! I can design a program tailored to your goals, schedule, and available equipment, then add it directly to your app calendar.\n\nWould you like me to create a custom plan for you?",
      newState: 'PLAN_CONFIRM',
      quickReplies: [
        { id: 'confirm_yes', text: 'Yes, build it!', action: 'CONFIRM_PLAN' },
        { id: 'confirm_no', text: 'Just give advice', action: 'DECLINE_PLAN' }
      ]
    };
  }

  // Handle stop plan intent detection
  private handleStopPlanIntentDetected(): AIServiceResponse {
    return {
      content: "I understand you'd like to stop creating the workout plan. Are you sure you want to cancel the plan creation process?\n\nI can return to general fitness advice instead.",
      newState: 'STOP_PLAN_CONFIRM',
      quickReplies: [
        { id: 'stop_yes', text: 'Yes, stop building', action: 'CONFIRM_STOP' },
        { id: 'stop_no', text: 'Continue with plan', action: 'DECLINE_STOP' }
      ]
    };
  }

  // Handle plan confirmation response
  private handlePlanConfirmation(message: string): AIServiceResponse {
    const isConfirming = /yes|build|create|go|sure|okay|ok/i.test(message);
    
    if (isConfirming) {
      return {
        content: "Perfect! Let's build your personalized plan. I'll need to ask you a few questions to create the best program for you.\n\nFirst, what's your main fitness goal?",
        newState: 'PLAN_INFO_GATHER',
        quickReplies: [
          { id: 'goal_muscle', text: 'Build Muscle', action: 'SET_GOAL', data: 'muscle gain' },
          { id: 'goal_strength', text: 'Get Stronger', action: 'SET_GOAL', data: 'strength' },
          { id: 'goal_fat_loss', text: 'Lose Fat', action: 'SET_GOAL', data: 'fat loss' },
          { id: 'goal_general', text: 'General Fitness', action: 'SET_GOAL', data: 'general fitness' }
        ]
      };
    } else {
      return {
        content: "No problem! I'm here to help with any fitness questions you have. Feel free to ask about exercises, nutrition, training tips, or anything else fitness-related.",
        newState: 'IDLE'
      };
    }
  }

  // Handle stop plan confirmation response
  private handleStopPlanConfirmation(message: string): AIServiceResponse {
    const isConfirmingStop = /yes|stop|cancel|quit|abort/i.test(message);
    
    if (isConfirmingStop) {
      return {
        content: "No problem! I've cancelled the workout plan creation. I'm here whenever you want to chat about fitness, ask questions, or if you change your mind about creating a plan later.",
        newState: 'IDLE',
        userInfoUpdates: {
          // Clear any collected plan info
          goal: undefined,
          experience: undefined,
          daysPerWeek: undefined,
          sessionLength: undefined,
          equipment: undefined,
          constraints: undefined,
          preferences: undefined,
        }
      };
    } else {
      return {
        content: "Great! Let's continue building your workout plan. Where were we...",
        newState: 'PLAN_INFO_GATHER'
      };
    }
  }

  // Handle information gathering process
  private async handleInfoGathering(message: string, userPlanInfo: UserPlanInfo): Promise<AIServiceResponse> {
    // Determine what info we still need
    const missingInfo = this.getMissingPlanInfo(userPlanInfo);
    
    if (missingInfo.length === 0) {
      // We have all the info, move to plan building
      return {
        content: "Perfect! I have everything I need. Let me create your personalized workout plan now...",
        newState: 'PLAN_BUILDING'
      };
    }

    // Ask for the next piece of information
    const nextInfo = missingInfo[0];
    return await this.askForSpecificInfo(nextInfo, message, userPlanInfo);
  }

  // Generate workout plan
  private async handlePlanBuilding(userPlanInfo: UserPlanInfo): Promise<AIServiceResponse> {
    try {
      // For now, use fallback plan for testing (remove this when OpenAI is configured)
      const planData = this.generateFallbackPlan(userPlanInfo);
      
      // Build response message (skip exercise checking for now to prevent blocking)
      let responseMessage = `ðŸŽ‰ **Your personalized workout plan is ready!**\n\n`;
      responseMessage += `**${planData.plan.name}**\n`;
      responseMessage += `â€¢ ${planData.plan.length_weeks} weeks, ${planData.plan.days_per_week} days per week\n`;
      responseMessage += `â€¢ Starting ${planData.plan.start_date}\n`;
      responseMessage += `â€¢ ${planData.workouts.length} different workout${planData.workouts.length > 1 ? 's' : ''}\n\n`;
      
      // Skip new exercise detection for testing to prevent blocking
      // const newExercises = await this.getNewlyCreatedExercises(planData);
      // if (newExercises.length > 0) { ... }
      
      responseMessage += `**Progression:** ${planData.plan.progression_model}\n\n`;
      responseMessage += `**Notes:** ${planData.plan.notes}\n\n`;
      responseMessage += `Take a look at your plan below and let me know what you think!`;
      
      return {
        content: responseMessage,
        newState: 'PLAN_PERSISTING',
        planData
      };
    } catch (error) {
      console.error('Plan generation error:', error);
      return {
        content: "I encountered an issue creating your plan. Let me try again with a simplified approach.",
        newState: 'PLAN_INFO_GATHER'
      };
    }
  }

  // Handle general fitness chat
  private async handleIdleChat(message: string, conversationHistory: ChatMessage[]): Promise<AIServiceResponse> {
    const response = await this.callOpenAI(
      SYSTEM_PROMPTS.IDLE,
      message,
      conversationHistory
    );

    return {
      content: response
    };
  }

  // Handle post-plan questions
  private async handlePostPlanQuestions(message: string, userPlanInfo: UserPlanInfo): Promise<AIServiceResponse> {
    const response = await this.callOpenAI(
      SYSTEM_PROMPTS.PLAN_EXPLAINED + `\n\nUser's plan context: ${JSON.stringify(userPlanInfo)}`,
      message,
      []
    );

    return {
      content: response
    };
  }

  // Ask for specific information with appropriate quick replies
  private async askForSpecificInfo(
    infoType: string,
    userMessage: string,
    userPlanInfo: UserPlanInfo
  ): Promise<AIServiceResponse> {
    switch (infoType) {
      case 'goal':
        return {
          content: "What's your main fitness goal?",
          quickReplies: [
            { id: 'goal_muscle', text: 'Build Muscle', action: 'SET_GOAL', data: 'muscle gain' },
            { id: 'goal_strength', text: 'Get Stronger', action: 'SET_GOAL', data: 'strength' },
            { id: 'goal_fat_loss', text: 'Lose Fat', action: 'SET_GOAL', data: 'fat loss' },
            { id: 'goal_general', text: 'General Fitness', action: 'SET_GOAL', data: 'general fitness' }
          ]
        };

      case 'experience':
        return {
          content: "What's your experience level with resistance training?",
          quickReplies: [
            { id: 'exp_beginner', text: 'Beginner', action: 'SET_EXPERIENCE', data: 'beginner' },
            { id: 'exp_intermediate', text: 'Intermediate', action: 'SET_EXPERIENCE', data: 'intermediate' },
            { id: 'exp_advanced', text: 'Advanced', action: 'SET_EXPERIENCE', data: 'advanced' }
          ]
        };

      case 'daysPerWeek':
        return {
          content: "How many days per week can you work out?",
          quickReplies: [
            { id: 'days_2', text: '2 days', action: 'SET_DAYS', data: 2 },
            { id: 'days_3', text: '3 days', action: 'SET_DAYS', data: 3 },
            { id: 'days_4', text: '4 days', action: 'SET_DAYS', data: 4 },
            { id: 'days_5', text: '5 days', action: 'SET_DAYS', data: 5 },
            { id: 'days_6', text: '6 days', action: 'SET_DAYS', data: 6 }
          ]
        };

      case 'sessionLength':
        return {
          content: "How long do you want each workout session to be?",
          quickReplies: [
            { id: 'time_30', text: '30 min', action: 'SET_SESSION_LENGTH', data: 30 },
            { id: 'time_45', text: '45 min', action: 'SET_SESSION_LENGTH', data: 45 },
            { id: 'time_60', text: '60 min', action: 'SET_SESSION_LENGTH', data: 60 },
            { id: 'time_90', text: '90 min', action: 'SET_SESSION_LENGTH', data: 90 }
          ]
        };

      case 'equipment':
        return {
          content: "What equipment do you have access to?",
          quickReplies: [
            { id: 'eq_gym', text: 'Full Gym', action: 'SET_EQUIPMENT', data: ['gym', 'barbell', 'dumbbells', 'machines'] },
            { id: 'eq_home_db', text: 'Home + Dumbbells', action: 'SET_EQUIPMENT', data: ['dumbbells', 'bodyweight'] },
            { id: 'eq_bodyweight', text: 'Bodyweight Only', action: 'SET_EQUIPMENT', data: ['bodyweight'] },
            { id: 'eq_bands', text: 'Bands + Bodyweight', action: 'SET_EQUIPMENT', data: ['bands', 'bodyweight'] }
          ]
        };

      default:
        return {
          content: "Let me know if you have any injuries or movements you'd like to avoid (or just say 'none'):",
        };
    }
  }

  // Determine what information is still missing
  private getMissingPlanInfo(userPlanInfo: UserPlanInfo): string[] {
    const missing: string[] = [];
    
    if (!userPlanInfo.goal) missing.push('goal');
    if (!userPlanInfo.experience) missing.push('experience');
    if (!userPlanInfo.daysPerWeek) missing.push('daysPerWeek');
    if (!userPlanInfo.sessionLength) missing.push('sessionLength');
    if (!userPlanInfo.equipment || userPlanInfo.equipment.length === 0) missing.push('equipment');
    
    return missing;
  }

  // Generate workout plan using AI
  private async generateWorkoutPlan(userPlanInfo: UserPlanInfo): Promise<WorkoutPlan> {
    const planPrompt = this.buildPlanGenerationPrompt(userPlanInfo);
    const systemPrompt = this.buildPlanSystemPrompt();
    
    try {
      const response = await this.callOpenAI(
        systemPrompt,
        planPrompt,
        []
      );

      // Try to parse JSON from the response
      const jsonMatch = response.match(/```json\s*([\s\S]*?)\s*```/);
      const jsonString = jsonMatch ? jsonMatch[1] : response;
      
      const plan = JSON.parse(jsonString);
      
      // Validate and process the plan
      const validatedPlan = await this.validateAndProcessPlan(plan, userPlanInfo);
      
      return validatedPlan;
    } catch (error) {
      console.error('Plan generation parsing error:', error);
      // Return a fallback plan
      return this.generateFallbackPlan(userPlanInfo);
    }
  }

  // Build system prompt for plan generation
  private buildPlanSystemPrompt(): string {
    return `You are a professional fitness trainer and workout plan generator. Your task is to create detailed, safe, and effective workout plans.

CRITICAL CONSTRAINTS:
1. ONLY use exercises that target these muscle groups: ${VALID_MUSCLE_GROUPS.join(', ')}
2. NEVER create exercises with invalid muscle groups
3. For each exercise, you MUST specify which muscle groups it targets
4. Ensure exercises match the available equipment
5. Follow progressive overload principles
6. Include proper warm-up and cool-down guidance

EXERCISE REQUIREMENTS:
- Use compound movements when possible
- Include specific sets, reps, and rest times
- Provide exercise variations for different experience levels
- Ensure exercises are safe for the user's constraints

PLAN STRUCTURE:
- Create balanced workouts that don't overtrain muscle groups
- Distribute volume appropriately across the week
- Include progression strategies (weight, reps, sets)
- Provide clear workout titles and organization

Return ONLY valid JSON following the exact schema provided. No additional text.`;
  }

  // Build prompt for plan generation
  private buildPlanGenerationPrompt(userPlanInfo: UserPlanInfo): string {
    const startDate = userPlanInfo.startDate ? new Date(userPlanInfo.startDate) : new Date();
    if (!userPlanInfo.startDate) {
      startDate.setDate(startDate.getDate() + ((1 + 7 - startDate.getDay()) % 7)); // Next Monday
    }
    
    const planLength = userPlanInfo.planLength || 8;
    
    return `Generate a workout plan with these specifications:

USER PROFILE:
- Primary Goal: ${userPlanInfo.goal}
- Experience Level: ${userPlanInfo.experience}
- Training Frequency: ${userPlanInfo.daysPerWeek} days per week
- Session Duration: ${userPlanInfo.sessionLength} minutes
- Available Equipment: ${userPlanInfo.equipment?.join(', ') || 'bodyweight only'}
- Training Constraints: ${userPlanInfo.constraints?.join(', ') || 'none'}
- Split Preference: ${userPlanInfo.preferences?.splitType || 'optimal for goal'}
- Favorite Exercises: ${userPlanInfo.preferences?.favoriteExercises?.join(', ') || 'none specified'}
- Exercises to Avoid: ${userPlanInfo.preferences?.avoidExercises?.join(', ') || 'none'}

PLAN REQUIREMENTS:
- Start Date: ${startDate.toISOString().split('T')[0]}
- Plan Duration: ${planLength} weeks
- Generate ${userPlanInfo.daysPerWeek} different workout templates
- Assign workouts to specific calendar dates for the entire ${planLength}-week period
- Include detailed exercise instructions with proper muscle group targeting

EXERCISE FORMAT - Each exercise MUST include:
- name: Clear, specific exercise name
- sets: Number of sets (integer)
- reps: Rep range (e.g., "8-12", "12-15", "20")
- rest_seconds: Rest time between sets (30-300 seconds)
- muscle_groups: Array of targeted muscles from valid list
- notes: Brief form cues or modifications

VALID MUSCLE GROUPS ONLY: ${VALID_MUSCLE_GROUPS.join(', ')}

\`\`\`json
{
  "plan": {
    "name": "8-Week ${userPlanInfo.goal} Plan",
    "start_date": "${startDate.toISOString().split('T')[0]}",
    "length_weeks": ${planLength},
    "days_per_week": ${userPlanInfo.daysPerWeek},
    "progression_model": "Progressive overload description",
    "notes": "Plan overview and important notes"
  },
  "workouts": [
    {
      "day_of_week": "Mon",
      "title": "Workout A",
      "estimated_minutes": ${userPlanInfo.sessionLength},
      "exercises": [
        {
          "name": "Barbell Bench Press",
          "sets": 4,
          "reps": "6-10",
          "rest_seconds": 120,
          "muscle_groups": ["Chest", "Shoulders", "Triceps"],
          "notes": "Control the weight, full range of motion"
        }
      ]
    }
  ],
  "calendar_assignments": [
    {"date": "${startDate.toISOString().split('T')[0]}", "workout_title": "Workout A"}
  ]
}
\`\`\``;
  }

  // Validate and process the generated plan
  private async validateAndProcessPlan(plan: WorkoutPlan, userPlanInfo: UserPlanInfo): Promise<WorkoutPlan> {
    // Validate plan structure
    if (!plan.plan || !plan.workouts || !plan.calendar_assignments) {
      throw new Error('Invalid plan structure');
    }

    // Validate muscle groups in exercises
    for (const workout of plan.workouts) {
      for (const exercise of workout.exercises) {
        if (exercise.muscle_groups) {
          // Filter out invalid muscle groups
          exercise.muscle_groups = exercise.muscle_groups.filter(muscle => 
            VALID_MUSCLE_GROUPS.includes(muscle)
          );
        }
      }
    }

    // Process and create new exercises if needed
    await this.processExercisesInPlan(plan);

    // Generate full calendar assignments if not provided
    if (plan.calendar_assignments.length === 0) {
      plan.calendar_assignments = this.generateCalendarAssignments(
        plan.plan.start_date,
        plan.plan.length_weeks,
        plan.plan.days_per_week,
        plan.workouts
      );
    }

    return plan;
  }

  // Generate fallback plan for error cases
  private generateFallbackPlan(userPlanInfo: UserPlanInfo): WorkoutPlan {
    const startDate = userPlanInfo.startDate ? new Date(userPlanInfo.startDate) : new Date();
    if (!userPlanInfo.startDate) {
      startDate.setDate(startDate.getDate() + ((1 + 7 - startDate.getDay()) % 7)); // Next Monday
    }

    const daysPerWeek = userPlanInfo.daysPerWeek || 3;
    const sessionLength = userPlanInfo.sessionLength || 45;
    const planLength = userPlanInfo.planLength || 8;

    // Create simple fallback workouts based on experience level
    const workouts = this.createFallbackWorkouts(daysPerWeek, sessionLength, userPlanInfo);
    const calendarAssignments = this.generateCalendarAssignments(
      startDate.toISOString().split('T')[0],
      planLength,
      daysPerWeek,
      workouts
    );

    return {
      plan: {
        name: `${planLength}-Week ${userPlanInfo.goal || 'Fitness'} Plan`,
        start_date: startDate.toISOString().split('T')[0],
        length_weeks: planLength,
        days_per_week: daysPerWeek,
        progression_model: 'Progressive overload - increase weight, reps, or sets each week',
        notes: 'Start with lighter weights to master form, then progressively increase intensity.'
      },
      workouts,
      calendar_assignments: calendarAssignments
    };
  }

  // Create fallback workouts based on user preferences
  private createFallbackWorkouts(daysPerWeek: number, sessionLength: number, userPlanInfo: UserPlanInfo): any[] {
    const hasGym = userPlanInfo.equipment?.includes('gym') || userPlanInfo.equipment?.includes('barbell');
    
    if (daysPerWeek <= 3) {
      // Full body workouts
      return [
        {
          day_of_week: 'Mon',
          title: 'Full Body A',
          estimated_minutes: sessionLength,
          exercises: hasGym ? [
            { name: 'Barbell Squat', sets: 3, reps: '8-12', rest_seconds: 120, muscle_groups: ['Quads', 'Glutes'] },
            { name: 'Bench Press', sets: 3, reps: '8-12', rest_seconds: 120, muscle_groups: ['Chest', 'Shoulders', 'Triceps'] },
            { name: 'Bent-Over Row', sets: 3, reps: '8-12', rest_seconds: 90, muscle_groups: ['Back', 'Biceps'] },
            { name: 'Overhead Press', sets: 3, reps: '8-12', rest_seconds: 90, muscle_groups: ['Shoulders', 'Triceps'] },
            { name: 'Plank', sets: 3, reps: '30-60s', rest_seconds: 60, muscle_groups: ['Abs'] }
          ] : [
            { name: 'Bodyweight Squat', sets: 3, reps: '12-20', rest_seconds: 60, muscle_groups: ['Quads', 'Glutes'] },
            { name: 'Push-ups', sets: 3, reps: '8-15', rest_seconds: 60, muscle_groups: ['Chest', 'Shoulders', 'Triceps'] },
            { name: 'Pike Push-ups', sets: 3, reps: '5-12', rest_seconds: 60, muscle_groups: ['Shoulders', 'Triceps'] },
            { name: 'Plank', sets: 3, reps: '30-60s', rest_seconds: 60, muscle_groups: ['Abs'] },
            { name: 'Glute Bridges', sets: 3, reps: '15-25', rest_seconds: 45, muscle_groups: ['Glutes', 'Hamstrings'] }
          ]
        }
      ];
    } else {
      // Upper/Lower split
      return [
        {
          day_of_week: 'Mon',
          title: 'Upper Body',
          estimated_minutes: sessionLength,
          exercises: hasGym ? [
            { name: 'Bench Press', sets: 4, reps: '8-12', rest_seconds: 120, muscle_groups: ['Chest', 'Shoulders', 'Triceps'] },
            { name: 'Bent-Over Row', sets: 4, reps: '8-12', rest_seconds: 90, muscle_groups: ['Back', 'Biceps'] },
            { name: 'Overhead Press', sets: 3, reps: '8-12', rest_seconds: 90, muscle_groups: ['Shoulders', 'Triceps'] },
            { name: 'Lat Pulldown', sets: 3, reps: '10-15', rest_seconds: 75, muscle_groups: ['Back', 'Biceps'] }
          ] : [
            { name: 'Push-ups', sets: 4, reps: '8-15', rest_seconds: 60, muscle_groups: ['Chest', 'Shoulders', 'Triceps'] },
            { name: 'Pike Push-ups', sets: 3, reps: '5-12', rest_seconds: 60, muscle_groups: ['Shoulders', 'Triceps'] },
            { name: 'Tricep Dips', sets: 3, reps: '8-15', rest_seconds: 60, muscle_groups: ['Triceps', 'Shoulders'] }
          ]
        },
        {
          day_of_week: 'Tue',
          title: 'Lower Body',
          estimated_minutes: sessionLength,
          exercises: hasGym ? [
            { name: 'Barbell Squat', sets: 4, reps: '8-12', rest_seconds: 120, muscle_groups: ['Quads', 'Glutes'] },
            { name: 'Romanian Deadlift', sets: 3, reps: '10-15', rest_seconds: 90, muscle_groups: ['Hamstrings', 'Glutes'] },
            { name: 'Walking Lunges', sets: 3, reps: '12-16', rest_seconds: 75, muscle_groups: ['Quads', 'Glutes'] }
          ] : [
            { name: 'Bodyweight Squat', sets: 4, reps: '15-25', rest_seconds: 60, muscle_groups: ['Quads', 'Glutes'] },
            { name: 'Single-Leg Glute Bridge', sets: 3, reps: '10-15', rest_seconds: 60, muscle_groups: ['Glutes', 'Hamstrings'] },
            { name: 'Reverse Lunges', sets: 3, reps: '12-16', rest_seconds: 60, muscle_groups: ['Quads', 'Glutes'] }
          ]
        }
      ];
    }
  }

  // Generate calendar assignments for the plan
  private generateCalendarAssignments(startDate: string, lengthWeeks: number, daysPerWeek: number, workouts: any[]): any[] {
    const assignments = [];
    const start = new Date(startDate);
    const workoutDays = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
    
    // Simple pattern: distribute workouts evenly throughout the week
    const daysBetween = Math.floor(7 / daysPerWeek);
    const selectedDays = [];
    for (let i = 0; i < daysPerWeek; i++) {
      selectedDays.push(workoutDays[i * daysBetween]);
    }

    for (let week = 0; week < lengthWeeks; week++) {
      for (let dayIndex = 0; dayIndex < daysPerWeek; dayIndex++) {
        const workoutDate = new Date(start);
        workoutDate.setDate(start.getDate() + (week * 7) + (dayIndex * daysBetween));
        
        const workoutTitle = workouts[dayIndex % workouts.length]?.title || `Workout ${dayIndex + 1}`;
        
        assignments.push({
          date: workoutDate.toISOString().split('T')[0],
          workout_title: workoutTitle
        });
      }
    }

    return assignments;
  }

  // Process exercises in plan and create new ones if needed
  private async processExercisesInPlan(plan: WorkoutPlan): Promise<void> {
    try {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) return;

      // Get existing exercises
      const { data: existingExercises } = await supabase
        .from('exercises')
        .select('name, id, muscle_groups');

      const existingExerciseNames = new Set(
        existingExercises?.map(ex => ex.name.toLowerCase()) || []
      );

      const exercisesToCreate = [];

      // Check each exercise in the plan
      for (const workout of plan.workouts) {
        for (const exercise of workout.exercises) {
          const exerciseName = exercise.name.toLowerCase();
          
          // If exercise doesn't exist, prepare to create it
          if (!existingExerciseNames.has(exerciseName)) {
            exercisesToCreate.push({
              name: exercise.name,
              muscle_groups: exercise.muscle_groups || ['Chest'], // Default fallback
              is_custom: true,
              created_by: user.id,
              equipment: this.inferEquipmentFromExerciseName(exercise.name)
            });
          }
        }
      }

      // Create new exercises if any
      if (exercisesToCreate.length > 0) {
        const { error } = await supabase
          .from('exercises')
          .insert(exercisesToCreate);

        if (error) {
          console.error('Error creating exercises:', error);
        }
      }
    } catch (error) {
      console.error('Error processing exercises in plan:', error);
    }
  }

  // Infer equipment from exercise name
  private inferEquipmentFromExerciseName(exerciseName: string): string | null {
    const name = exerciseName.toLowerCase();
    if (name.includes('barbell')) return 'Barbell';
    if (name.includes('dumbbell')) return 'Dumbbells';
    if (name.includes('machine')) return 'Machine';
    if (name.includes('cable')) return 'Cable';
    if (name.includes('bodyweight') || name.includes('push-up') || name.includes('pull-up')) return 'Bodyweight';
    return null;
  }

  // Get list of newly created exercises
  private async getNewlyCreatedExercises(plan: WorkoutPlan): Promise<string[]> {
    try {
      const { data: existingExercises } = await supabase
        .from('exercises')
        .select('name');

      const existingExerciseNames = new Set(
        existingExercises?.map(ex => ex.name.toLowerCase()) || []
      );

      const allPlanExercises = new Set<string>();
      
      // Collect all unique exercise names from the plan
      for (const workout of plan.workouts) {
        for (const exercise of workout.exercises) {
          allPlanExercises.add(exercise.name);
        }
      }

      // Return exercises that don't exist in the database
      return Array.from(allPlanExercises).filter(exerciseName => 
        !existingExerciseNames.has(exerciseName.toLowerCase())
      );
    } catch (error) {
      console.error('Error getting newly created exercises:', error);
      return [];
    }
  }

  // Call OpenAI API with retry logic
  private async callOpenAI(
    systemPrompt: string,
    userMessage: string,
    conversationHistory: ChatMessage[] = []
  ): Promise<string> {
    if (!this.apiKey) {
      throw new Error('OpenAI API key not configured');
    }

    const messages = [
      { role: 'system', content: systemPrompt },
      ...conversationHistory.slice(-6).map(msg => ({
        role: msg.sender === 'user' ? 'user' as const : 'assistant' as const,
        content: msg.content
      })),
      { role: 'user', content: userMessage }
    ];

    for (let attempt = 0; attempt < MAX_RETRIES; attempt++) {
      try {
        const response = await fetch(OPENAI_API_URL, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${this.apiKey}`,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            model: OPENAI_MODEL,
            messages,
            max_tokens: 1500,
            temperature: 0.7,
          }),
        });

        if (!response.ok) {
          const error = await response.text();
          throw new Error(`OpenAI API error: ${response.status} - ${error}`);
        }

        const data = await response.json();
        return data.choices[0]?.message?.content || 'I apologize, but I encountered an error processing your request.';
      } catch (error) {
        console.error(`OpenAI API attempt ${attempt + 1} failed:`, error);
        
        if (attempt === MAX_RETRIES - 1) {
          throw error;
        }
        
        await new Promise(resolve => setTimeout(resolve, RETRY_DELAY * (attempt + 1)));
      }
    }

    throw new Error('Max retries exceeded');
  }


  // Error response
  private getErrorResponse(): AIServiceResponse {
    return {
      content: "I'm experiencing some technical difficulties right now. Please try again in a moment, or feel free to ask me any fitness questions!"
    };
  }
}

export default new AIService();
export type { AIServiceResponse, QuickReply };
